Dec 19th, 2013

- Brought a powered USB hub from work to allow keyboard/mouse
  and USB wifi adapter to be used at same time.  Also using it
  to power the rpi.
- Got wireless adapter working:
    http://databoyz.wordpress.com/tag/how-to-setup-network-and-wpa_supplicant-conf-file-on-raspberry-pi/
- Installed fbtft drivers:
    https://github.com/notro/fbtft/wiki#install
- Wired ili9340 display:
  https://github.com/notro/fbtft/wiki/LCD-Modules#adafruit-22
  My display isn't the Adafruit one, but it appears to be compatible.
- Tried enabling display with
    sudo modprobe fbtft_device name=adafruit22
  Didn't work: noticed in the dmesg output that reported resolution
  was wrong.  This driver is apparently for the old version of the 2.2"
  Adafruit display.

Dec 20th, 2013

- Display is working!  Enabled with
    sudo modprobe fbtft_device name=adafruit22a
  And it worked perfectly!  Ran X windows with
    FRAMEBUFFER=/dev/fb1 startx
  and it ran!  Framerate seems pretty reasonable.
- Started enclosure design in LibreCad: plate.dxf is the outline of
  the top/bottom plates with (I think) correctly-sized holes for the
  6-32 screws that will secure the standoffs.
- Ordered board mounts from Adafruit - these are basically standoffs
  that have slots that fit the edge of a PC board.  The Rpi doesn't
  really have mounting holes as such, so these seem to be the best
  way to fasten the Rpi to the bottom plate.

Dec 21st, 2013

- Ordered .25"x1" hex 6-32 F/F standoffs from Ebay.  (25 for $8 with free
  shipping!)  Plan is that 4 of these will connect the plates to each other.
  The Rpi will be attached to the bottom plate and the display and buttons
  will be attached to the top plate.
- Changed enclosure drawing to make plates 127mm x 77mm: this is 5"x3"
  (actually slightly more than 3").  This will leave some room for
  attaching the board mounts for the pi: 5"x2.5" (my original dimensions)
  would have the edges of the Rpi right at the edge of the plates
  in the long dimension, leaving no space for the board mounts.

Dec 22nd, 2013

- Redoing enclosure design to see if I can make it work with the
  top and bottom plates being 69mm (2.75") in the narrow dimension.
  This is to try to take advantage of the following laser
  cutting service:
    http://www.spikenzielabs.com/Catalog/index.php?main_page=product_info&cPath=13&products_id=22
  $20 for arbitrary cuts on a 5.5"x5.5" sheet of 1/8" acrylic.
- Just found out that the CAD drawing (of the RPi outline) was
  a BOTTOM VIEW. Sigh.
- Found out that the official PCB dimensions are 85mm x 56.2mm.
  Also, according to
    http://www.raspberrypi.org/archives/tag/mounting-holes
  the mounting hole locations are at x=25.5mm, y=18.0mm and
  x=80.1mm, y=43.6mm, relative to the bottom left corner.  Updated
  plate.dxf to reflect this.
- The mounting holes are meant to accept M2.5 screws.  Ordered from
  Ebay:
  - 25x 6mm nylon M2.5 M/F standoffs
  - 25x M2.5 nylon nuts
  - 50x M2.5 8mm screws
  The idea is that the female part of the standoff will be attached
  to the bottom plate with the 8mm screw, and that the PCB itself
  will be attached by fastening the nut to the male part of the
  standoff.  Since the standoffs and nuts are nylon, hopefully this will
  make it less likely to damage the PCB (than metal fasteners would be).
  The acrylic will be 1/8", which is 3.175mm.  This should mean that
  a bit less than 4mm of the screw will be screwed into the female part
  of the standoff, which seems reasonable.
- The standoffs are 6mm, while the board mounts are .25", which is
  about 6.4mm.  I'm hoping that the .4mm won't make a big difference.
  If it is an issue, probably I can put a washer between the standoff
  and the plate to give it a bit of extra height.

Dec 23rd, 2013

- Did a CAD drawing of the LCD.  Added it to plate.dxf.  Discovered that
  the only way that both the LCD and buttons PCB will fit is if the
  the LCD is vertical.  The LCD fits quite nicely that way, and
  makes better use of the available space.
- Started a CAD drawing of the buttons PCB, and discovered that the
  5cm x 7cm protoboard I ordered previously will not fit, either
  horizontally or vertically.  Horizontally, 5cm is too wide to fit
  between the standoffs.  Vertically, 7cm would cause the PCB to stick
  out from the top plate on one or both sides.  Ordered some 4cm x 6cm
  protoboards from Ebay (from Colorado, they will probably arrive
  sooner than the 5x7 ones from China).
- Added a preliminary button PCB board outline and guess at screw hole
  locations and sizes to plate.dxf.  When the PCB and buttons arrive
  I will need to come up with some kind of accurate drawing.
  The 4cm x 6cm size does fit very nicely in a horizontal orientation.
  Probably only two rows of buttons will be possible, so maybe
  2 rows by 3 columns.  Should fit and hopefully also leave room for
  the debouncing circuit.
- Ordered some stuff from allelectronics.com:
  * caps and resistor networks for debounce circuit
  * 2x13 (26 pin) female IDC headers (for connecting to RPi
    GPIO header)
  * 5" 8x1 jumpers
  * 1.375" 6-32 F/F standoffs (in case the 1" ones don't leave enough
    room between the top and bottom plates)
- Had an idea for the wiring: could the wires from the 8x1 jumpers
  be crimped directly into the 2x13 IDC header, making connections to
  arbitrary pins?  That would hugely simplify the wiring: the LCD
  and button board could simply receive connections via a standard
  8x1 header (the LCD already has one, could easily solder one
  on the button PCB.)  8 pins is perfect for VCC, GND, and 1 signal
  for each of the 6 buttons.

Dec 24th, 2013 - Dec 31st, 2013

- Created initial version of software: using ncurses for the UI,
  but making the models/controllers completely independent of the views
  so ports to other UI toolkits will be possible.  Started by
  implementing a music player using mpg321 and ogg123 via the
  remote control interface as a back end.  Works fairly well for
  mp3 playback, ogg playback needs some work because ogg123 doesn't
  really implement the remote control interface fully.
- Pushed repo to github: https://github.com/daveho/carpi
- Ordered square pushbuttons from Adafruit: the ones I ordered from
  Ebay haven't arrived.  This is the problem with ordering parts
  from China: you don't know whether the parts will arrive in a
  timely manner (or at all).

Jan 1st, 2014

- Idea: use attiny2313 to debounce pushbuttons.  This should greatly
  simplify the pushbutton circuit (no resistors/caps needed).
  The datasheet says it can run from 3V, and this should allow
  signal compatibility with the RPi.
- Started program to run on attiny2313 to do the button debouncing.
- Allocating RPi GPIO pins for button inputs:
  * Button 1: GPIO2 (P1-3)
  * Button 2: GPIO3 (P1-5)
  * Button 3: GPIO4 (P1-7)
  * Button 4: GPIO17 (P1-11)
  * Button 5: GPIO27 (P1-13)
  * Button 6: GPIO22 (P1-15)
  [Pins used by LCD: GPIO18, SCLK, MOSI, CE0, GPIO25, GPIO24]

Jan 2nd, 2014

- Used Eagle CAD to capture the pushbutton circuit and design a
  PCB for it.  My plan is to have the PCB made at OSHPark.com
  (they purchased batchpcb.com, and seem to have a very similar
  service).  First I will test the circuit (and the firmware)
  on a breadboard.
- Built the circuit on the breadboard, with some bugfixes the
  firmware works fine.

Jan 3rd, 2014

- I got the placement of the buttons wrong on the PCB (it was kind of
  hard to visualize because the board will be mounted upside down.)
  Rather than re-routing, I just changed the schematic and the
  firmware to reflect the button placement.  No biggie.
- Made various tweaks to the PCB.  In particular, made it just a bit
  bigger so the standoffs are a reasonable distance from the cutout
  in the top plate that will provide access to the buttons.
- Ordered PCBs from OSHPark - 3 boards for about $20.
- Did plate drawings and a combined top/bottom plate drawing, purchased
  the Mini Cut service ($20) from SpikenzieLabs, sent them my drawing.
  Hopefully it's OK - I used pretty much all of the available area.

Jan 4th, 2014

- Preliminary implementation of playing videos using omxplayer.
  Since omxplayer only exists on the RPi,  I can't actually test this
  on my laptop.  I've reached the point where I will need to
  do development on the RPi itself!

Jan 5th, 2014

- Refactored button debouncing firmware to be driven by a timer
  interrupt, and to enter low power mode between interrupts.
  Seems to work: might be interesting to measure the current
  draw.  The RPi is supposed to be able to source about 50 mA:
  the attiny2313 should need much, much less than that.

Jan 6th, 2014

- Connected the button circuit to the RPi.  First, just connected
  3.3V power to the attiny2313 and verified that the button outputs
  changed voltage appropriately when the buttons were pressed.
  Next, connected the button outputs to the assigned GPIO pins
  on the RPi.  Unfortunately, there is a problem: when PD2 (button 5
  output) is connected to GPIO (P1-5) 3 on the RPi, it does not boot
  successfully.  The failure mode is that the video mode is set
  incorrectly (looks like standard VGA resolution rather than the
  full 1280x1024 supported by the monitor I'm using), and the
  boot hangs after enumerating USB devices.  The problem appears
  to be on the RPi side: if any output is connected to GPIO 3, the
  RPi doesn't boot.  With some experimentation, it appears that
  GPIO 23 (P1-16) doesn't cause the same problem.  So, when the button
  PCBs arrive, I'll need to cut the connection to P1-5 on the RPi
  header and jumper PD2 to P1-16.  Could be worse, I suppose.
- Good news! Discovered that GPIO3 (SCL) causes the RPi to boot
  in safe mode when pulled to ground, which is what the attiny2313
  outputs when button 5 is not pressed.  Adding "avoid_safe_mode=1"
  to /boot/config.txt allows the RPi to boot normally.  Sweet.
  No changes should be necessary to the button PCB after all.
  Here's the documentation of this behavior:
    http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&t=27457
    http://elinux.org/RPI_safe_mode
- Idle thought: if the attiny2313 used 0=pressed, 1=not pressed for the
  button outputs, we wouldn't need avoid_safe_mode=1, and as a bonus,
  pressing button 5 on power-up would cause the RPi to boot in
  safe mode.  Should probably go with this plan.
- Made this change (outputting 0=pressed instead of 1=pressed).
  Verified that the RPi does boot normally without avoid_safe_mode=1.

Jan 7th, 2014

- Built wiringPi library from source.  Used the command
    gpio readall
  and verified that all of the inputs being driven by the button
  circuit are high (which is the expected state when the buttons aren't
  pressed.)  This is a good confirmation that the button input is
  being detected correctly.
